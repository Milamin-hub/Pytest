*a_1, a_2 = {"a": 1, "b": 2, "c": 3}
k_1 = (1, 2, 3)
l_1 = list(k_1)
s_1 = set(l_1)
print(*k_1, *l_1, *s_1, *a_1, *a_2)  # Распаковываем кортеж, список и множества, словарь

def summa(a, b, c):
    return a + b + c
d1 = {"a": 1, "b": 2, "c": 3}
print("summa:", summa(**d1)) # Распаковьваем словарь
t, d2 = (1, 2), {"c": 3} # Можно комбинировать значения
print("summa:", summa(*t, **d2)) # Добавленние значений кортежа и словаря

# Анонимная функция не имеет имени и описывается с помощью ключевого слова lambda

f = lambda х, у=2: х + у
print("lambda func: ", f(5)) # Выведет: 7
print("lambda func: ", f(5, 6)) # Выведет: 11

# Сортировка без учета регистра символов

arr_1 = ["Un1", "On2", "An3"]
arr_1.sort(key=lambda s: s.lower())
for i in arr_1:
    print(i, end=" ") # Результат выполнения: An3 On2 Un1
print()

# ♦ yield позволяет приостановить выполнение функции и превратить функцию в генератор.
# ♦ Функцией - генератором называется функция, которая при последовательных вызовах
# возвращает очередной элемент какой-либо последовательности.

def func(x, у):
    for i in range(x, x + 1) :
        yield i ** у
for n in func(3, 3):
    print(n, end=" ") # Выводит степень числа x
print()

# ♦ Получается, что с помощью обычных функций мы можем вернуть все значения сразу в виде
# списка, а с помощью функций-генераторов — только одно значение за раз.

