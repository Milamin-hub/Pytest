# Примесь — это класс, включающий какие-либо атрибуты и методы, которые необходимо добавить к другим классам

class Mixin: # Определяем сам класс-примесь
    attr = 0 # Определяем атрибут примеси
    def mixin_method(self): # Определяем метод примеси
        print("Метод примеси:1")
class Class1 (Mixin):
    def method1(self):
        print("Метод класса: 1")
class Class2 (Class1, Mixin):
    def method2(self):
        print("Метод класса: 2")

cl = Class1()
cl.method1()
cl.mixin_method() # Class1 поддерживает метод примеси
c2 = Class2()
c2.method1()
c2.method2()
c2.mixin_method() # Class2 также поддерживает метод примеси

# ♦ __getattribute__(self, <Атрибут>) — вызывается при обращении к любому атрибуту класса. Чтобы избежать зацикливания
# ♦ __setattr__(self, <Атрибут>, <3начение>) — вызывается при попытке присваивания значения атрибуту экземпляра класса
# ♦ __1еп__(self) — вызывается при использовании функции 1еп(), а также для проверки
# объекта на логическое значение при отсутствии метода__bool__()
# ♦ __bool__(self) — вызывается при использовании функции bool();
# ♦ __int__(self) — вызывается при преобразовании объекта в целое число с помощью функции int();
# ♦ __float__(self) — вызывается при преобразовании объекта в вещественное число с помощью функции float();
# ♦ __complex__(self) — вызывается при преобразовании объекта в комплексное число с помощью функции complex();
# ♦ __round__(self, n) — вызывается при использовании функции round ();
# ♦ __index__(self) — вызывается при использовании функций bin(), hex() и oct();
# ♦ __repr__(self) и __ str__(self) — служат для преобразования объекта в строку

# ♦ х + у — слож ением.__add__(у);
# ♦ у + х — сложение (экземпляр класса справа): х.__radd__(у);
# ♦ х += у — сложение и присваивание: х.__iadd__(у);
# ♦ х - у — вычитание: х.sub(у);
# ♦ у - х — вычитание (экземпляр класса справа): х.__rsub__(у);
# ♦ х -= у — вычитание и присваивание: х.__isub__(у);
# ♦ х * у — умножением x.__mul__(у);
# ♦ у * х — умножение (экземпляр класса справа): х.__rmul__(у);
# ♦ х *= у — умножение и присваивание: х.__imul__(у);
# ♦ х / у — деление x.__truediv __(у);
# ♦ у / х — деление (экземпляр класса справа): х.__rtruediv __(у);
# ♦ х /= у — деление и присваивание x.__itruediv__(у);
# ♦ х // у — деление с округлением вниз  x.__floordiv__(у);
# ♦ у // х — деление с округлением вниз (экземпляр класса справа): х.__rfioordiv__(у);
# ♦ х //= у — деление с округлением вниз и присваиванием. x__ifloordiv__(у);
# ♦ х % у — остаток от деления: х.__mod__(у);
# ♦ у % х — остаток от деления (экземпляр класса справа): х.__rmod__(у);
# ♦ х %= у — остаток от деления и присваивание: х .__imod__(у);
# ♦ х ** у — возведение в степ ен ьм .__pow__(у);
# ♦ у ** х — возведение в степень (экземпляр класса справа): х.__rpow__(у);
# ♦ х **= у — возведение в степень и присваивание: х.__ipow__(у);
# ♦ -х — унарный минус: х.__neg__();
# ♦ +х — унарный плюс: х.__pos__();
# ♦ abs(х) — абсолютное значение: х.__abs__().

# ♦ ~х — двоичная инверсия: х.__invert__();
# ♦ х & у — двоичное И: х.__and__(у);
# ♦ у & х — двоичное И (экземпляр класса справа): х.__rand__(у);
# ♦ х &= у — двоичное И и присваивание: х.__iand__(у);
# ♦ х | у — двоичное ИЛИ: х.__or__(у);
# ♦ у | х — двоичное ИЛИ (экземпляр класса справа): х.__rоr__(у);
# ♦ х |= у — двоичное ИЛИ и присваивание: х.__ior__(у);
# ♦ х ~ у — двоичное исключающее ИЛИ: х.__хоr__(у);
# ♦ у ~ х — двоичное исключающее ИЛИ (экземпляр класса справа): х.__rхоr__(у);
# ♦ х ~= у — двоичное исключающее ИЛИ и присваивание: х.__ixor__(у);
# ♦ х << у — сдвиг влево: х.__lshift __(у);
# ♦ у >> х — сдвиг влево (экземпляр класса справа): х.__rishift__(у);
# ♦ х <<= у — сдвиг влево и присваивание: х.__ilshift__(у);
# ♦ х >> у — сдвиг вправо: х.__rshift __(у);
# ♦ у >> х — сдвиг вправо (экземпляр класса справа): х ._rrshift___(у);
# ♦ х >>= у — сдвиг вправо и присваивание: х.irshift__(у).
# ♦ х == у — равно: х.__eq__(у);
# ♦ х != у — не равно: х.__пе__(у);
# ♦ х < у — меньше: х.__it__(у);
# ♦ х > у — больше: х.__gt__(у);
# ♦ х <= у — меньше или равно: х._1е__(у);
# ♦ х >= у — больше или равно: х.__gе__(у);
# ♦ у in х — проверка на вхождение: х.__contains__(у)