import test46
import concurrent.futures as cf

# Параллельное программирование

# ♦ Процесс — это независимая единица исполнения, выполняющаяся в отдельной области памяти.

# ♦ Поток — зависимая единица исполнения, работающая внутри процесса, в его области памяти.

# ♦ Python предоставляет два набора инструментов для многопоточного и многопроцессного
# программирования: высокоуровневые и низкоуровневые

# Высокоуровневые инструменты

# ♦ Инструменты для выполнения параллельных задач содержатся в модуле concurrent.futures.

# В этом модуле реализованы два класса: ThreadPoolExecutor и ProcessPoolExecutor.
# Первый выполняет указанные задачи в отдельных потоках, второй — в отдельных процессах.

# Набор методов

# ♦ submit(<Функция>[,<3начения параметров функции>]) — запускает на выполнение 
# в отдельном потоке(процессе) указанную в первом параметре функцию и передает ей 
# значения, указанные в последующих параметрах.

# exemple func
"""
def func(p1, p2, p3):
    ...

func_thread = multi_thread.submit(func, 1, 30, p3="special")
"""

# ♦ map()-(Функция,Последовательность[Последовательность][timeout=None]...)
# Аналог функции map(), за тем исключением, что каждый вызов указанной
# функции выполняется в отдельном потоке(процессе).

# ♦ shutdown([wait=True]) — предписывает текущему экземпляру класса 
# завершить выпол­нение всех запущенных и еще не завершенных задач.
# Если параметру wait присвоить значение False, метод не будет 
# ждать завершения запущенных задач.

# exemple
"""
fl = multi_thread.submit(. . . )
f2 = multi_thread.submit(. . . )
f3 = multi_thread.submit(. . . )
multi_thread.shutdown()
"""
# Мы можем использовать языковую конструкцию with и 
# исключить явный вызов метода shutdown()
"""
with concurrent.futures.ThreadPoolExecutor() as multi_thread:
    fl = multi_thread.submit(. . . )
    f2 = multi_thread.submit(. . . )
    f3 = multi_thread.submit(. . . )
"""

# ♦ result([timeout=None]) — возвращает результат, подготовленный текущей задачей. 
# Если задача в данный момент еще выполняется, ожидает завершения ее работы.

# ♦ exception([timeout=None]) — возвращает исключение, возбужденное при выполнении 
# текущей задачи. Если задача в данный момент еще выполняется, ожидает завершения 
# ее работы. Если задача выполнилась успешно, возвращает None.

# ♦ cancel() — пытается прервать выполнение текущей задачи. Возвращает True
# в случае успеха и False в случае неудачи. В случае успешного прерывания
# задачи возбуждается исключение CancelledError.

# ♦ running() - возвращает True, если текущая задача выполняется 
# и не может быть пре­рвана и False - противном случае.

# ♦ done() — возвращает True, если текущая задача завершилась
# или была прервана, и False — в противном случае;

# ♦ add_done_callback(<Функция>) — задает функцию, которая будет
# выполнена по завер­шении или при прерывании текущей задачи.

# ♦ wait(<3адачи>[,timeout=None][,return_when=ALL_COMPLETED]) — ждет, пока
# задачи, указанные в первом параметре в виде последовательности, не будут
# выполнены или прерваны.

# ♦ as_completed(<3адачи>[,timeout=None]) — возвращает итератор, с помощью которого
# можно перебрать все завершенные или прерванные задачи


with cf.ThreadPoolExecutor() as tpe:
    f1 = tpe.submit(pow, 12, 456)
    f2 = tpe.submit(pow, 78, 812)
    f3 = tpe.submit(pow, 64, 379)
    f4 = tpe.submit(pow, 99, 587)
    print("\n%s" % f1.result())
    print("\n%s" % f2.result())
    print("\n%s" % f3.result())
    print("\n%s" % f4.result())


def main():
    arr1 = [123, 789, 456, 95]
    arr2 = [456, 123, 789, 97]
    with cf.ProcessPoolExecutor() as p_pe:
        f = p_pe.map(pow, arr1, arr2)
        for r in f:
            print(r)

if __name__ == "__main__":
    main()